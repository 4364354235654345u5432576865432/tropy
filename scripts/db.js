'use strict'

require('shelljs/make')

const assert = require('assert')
const pkg = require('../package')
const log = require('./log')
const { join, dirname, relative } = require('path')
const { Database } = require('../lib/common/db')
const { compact, strftime } = require('../lib/common/util')
const home = join(__dirname, '..')
const cwd = process.cwd()
const SCHEMA = join(home, 'db', 'schema')
const MIGRATE = join(home, 'db', 'migrate')

target.create = async (args = []) => {
  const domain = args[0] || 'project'
  const file = args[1] || join(home, 'db', `${domain}.db`)
  const name = args[2] || 'Minos'

  rm('-f', file)

  const path = await Database.create(file, { name })
  info(`created "${name}" as ${relative(cwd, path)}`)
}

target.migrate = async (args = []) => {
  const domain = args[0] || 'project'
  const schema = join(SCHEMA, `${domain}.sql`)
  const tmp = join(home, 'tmp.db')

  rm('-f', tmp)
  rm('-f', schema)

  const db = new Database(tmp)

  try {
    await db.migrate(join(MIGRATE, domain))
    const version = await db.version()

    ;(`--
-- This file is auto-generated by executing all current
-- migrations. Instead of editing this file, please create
-- migrations to incrementally modify the database, and
-- then regenerate this schema file.
--
-- To create a new empty migration, run:
--   node scripts/db migration -- ${domain} [name] [sql|js]
--
-- To re-generate this file, run:
--   node scripts/db migrate
--

-- Save the current migration number
PRAGMA user_version=${version};

-- Load sqlite3 .dump
`
    ).to(schema)

    exec(`sqlite3 ${tmp} .dump >> ${schema}`)
    'PRAGMA foreign_keys=ON;'.toEnd(schema)

    info(`migrated ${domain} to #${version}`)
    info(`schema saved as ${relative(cwd, schema)}`)

  } finally {
    await db.close()
    rm(tmp)
  }
}

target.viz = async (args = []) => {
  const domain = args[0] || 'project'
  const file = args[1] || join(home, 'db', `${domain}.db`)
  const pdf = args[2] || join(home, 'doc', `${domain}.db.pdf`)
  const viz = join(home, 'node_modules', '.bin', 'sqleton')

  assert(test('-f', file), `${file} not found`)
  mkdir('-p', dirname(pdf))

  const db = new Database(file)

  try {
    const version = await db.version()

    exec([
      viz,
      `-t "${pkg.productName} #${version}"`,
      '-f "Helvetica Neue"',
      `-o ${pdf}`,
      file
    ].join(' '))

    info(`${domain} visual saved as ${relative(cwd, pdf)}`)

    return [pdf, version]

  } finally {
    await db.close()
  }
}

target.migration = (args = []) => {
  const domain = args[0] || 'project'
  const name = args[1]
  const type = args[2] || 'sql'
  const file = migration(name, type)
  const path = join(MIGRATE, domain, file)

  if (type === 'js') {
    (`'use strict'
exports.up = function ${name}$up(tx) {
  // Return a promise here!
}`).to(path)
  } else {
    ('').to(path)
  }

  info(`migration saved as ${relative(cwd, path)}`)
}

target.all = async (...args) => {
  await target.migrate(...args)
  await target.create(...args)
  await target.viz(...args)
}

target.rules = () => {
  for (let rule in target) info(rule)
}


function info(msg) {
  log.info(msg, { tag: 'db' })
}

function migration(name, type) {
  assert(type === 'sql' || type === 'js',
    `migration type '${type}' not supported`)
  return compact([strftime('%y%m%d%H%M'), name, type]).join('.')
}
