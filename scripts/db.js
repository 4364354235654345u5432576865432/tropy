'use strict'

require('shelljs/make')

const assert = require('assert')
const pkg = require('../package')
const log = require('./log')

const { join, dirname } = require('path')
const { assign } = Object
const { Database } = require('../lib/common/db')
const { Migration } = require('../lib/common/migration')
const { strftime } = require('../lib/common/util')

const home = join(__dirname, '..')
const DB = join(home, 'db', 'project.db')
const SCHEMA = join(home, 'db', 'schema', 'project.sql')
const MIGRATIONS = join(home, 'db', 'migrate', 'project')


target.create = async (args = []) => {
  const file = args[0] || DB
  const name = args[1] || 'Tropy'

  rm('-f', file)

  const path = await Database.create(file, { name })
  info(`created project "${name}" at ${path}`)
}

target.migrate = async () => {
  const tmp = join(home, 'tmp.db')

  rm('-f', tmp)
  rm('-f', SCHEMA)

  const db = new Database(tmp)

  try {
    await db.migrate(MIGRATIONS)
    const version = await db.version()

    ;(`--
-- This file is auto-generated by executing all current
-- migrations. Instead of editing this file, please create
-- migrations to incrementally modify the database, and
-- then regenerate this schema file.
--
-- To create a new empty migration, run:
--   npm run db -- migration -- [name] [sql|js]
--
-- To re-generate this file, run:
--   npm run db -- migrate
--

-- Save the current migration number
PRAGMA user_version=${version};

-- Load sqlite3 .dump
`
    ).to(SCHEMA)

    exec(`sqlite3 ${tmp} .dump >> ${SCHEMA}`)
    'PRAGMA foreign_keys=ON;'.toEnd(SCHEMA)

    info(`schema migrated to #${version}`)
    info(`schema written to ${SCHEMA}`)

  } finally {
    await db.close()
    rm(tmp)
  }
}

target.viz = async (args = []) => {
  const sql = args[0] || DB
  const pdf = args[1] || join(home, 'doc', 'db.pdf')
  const viz = join(home, 'node_modules', '.bin', 'sqleton')

  assert(test('-f', sql), `${sql} not found: run \`npm run db -- create\``)
  mkdir('-p', dirname(pdf))

  const db = new Database(sql)

  try {
    const version = await db.version()

    exec([
      viz,
      `-t "${pkg.productName} #${version}"`,
      '-f "Helvetica Neue"',
      `-o ${pdf}`,
      sql
    ].join(' '))

    info(`visual written to ${pdf}`)

    return [pdf, version]

  } finally {
    await db.close()
  }
}

target.migration = (args = []) => {
  if (args.length < 2) args.push('sql')

  const [type, name] = args.reverse()
  const file = migration(name, type)

  const content = (type === 'sql') ?  '' : `'use strict'
exports.up = function ${name}$up(tx) {
  // Return a promise here!
}`

  content.to(join(Migration.root, file))
  info(`migration ${file} created...`)
}

target.all = async () => {
  await target.migrate()
  await target.create()
  await target.viz()
}


target.rules = () => {
  for (let rule in target) info(rule)
}


function info(msg) {
  log.info(msg, { tag: 'db' })
}

function migration(name, type) {
  assert(type === 'sql' || type === 'js',
      `migration type '${type}' not supported`)

  return [strftime('%y%m%d%H%M'), name, type]
    .filter(x => x)
    .join('.')
}


module.exports = assign({}, target)
